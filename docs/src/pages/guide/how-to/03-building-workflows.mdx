# Building Workflows

Workflows in Mastra are graph-based state machines that execute complex sequences of operations. They support:

- Sequential and parallel execution
- Conditional branching
- Data validation
- Error handling and retries
- Variable passing between steps

Let's build a pizza ordering workflow to demonstrate these concepts.

## Creating Steps

First, let's create the individual steps for our pizza ordering process:

```ts filename="src/mastra/workflows/index.ts" showLineNumbers copy
import { Step, Workflow } from "@mastra/core";
import { z } from "zod";

// Step 1: Validate the order and calculate price
const validatePizzaOrder = new Step({
  id: "validatePizzaOrder",
  inputSchema: z.object({
    size: z.enum(["small", "medium", "large"]),
    toppings: z.array(z.string()),
    specialInstructions: z.string().optional(),
  }),
  outputSchema: z.object({
    isValid: z.boolean(),
    price: z.number(),
    estimatedTime: z.number(),
  }),
  action: async ({ data }) => {
    const basePrice = {
      small: 10,
      medium: 15,
      large: 20,
    }[data.size];

    return {
      isValid: true,
      price: basePrice + data.toppings.length * 1.5,
      estimatedTime: 30, // minutes
    };
  },
});

// Step 2: Process payment
const processPizzaPayment = new Step({
  id: "processPizzaPayment",
  inputSchema: z.object({
    price: z.number(),
  }),
  outputSchema: z.object({
    transactionId: z.string(),
    status: z.enum(["success", "failed"]),
  }),
  action: async ({ data }) => {
    return {
      transactionId: `TXN-${Math.random().toString(36).substring(7)}`,
      status: "success",
    };
  },
});

// Step 3: Notify kitchen
const notifyKitchen = new Step({
  id: "notifyKitchen",
  inputSchema: z.object({
    status: z.enum(["success", "failed"]),
  }),
  outputSchema: z.object({
    chefName: z.string(),
    orderStatus: z.enum(["preparing", "in-oven", "ready"]),
    startTime: z.string(),
  }),
  action: async ({ data }) => {
    return {
      chefName: "Chef Mario",
      orderStatus: "preparing",
      startTime: new Date().toISOString(),
    };
  },
});
```

## Creating the Workflow

Now let's create a workflow that combines these steps:

```ts filename="src/mastra/workflows/index.ts" showLineNumbers copy
const pizzaWorkflow = new Workflow({
  name: "pizza-order-workflow",
  // Define the schema for initial workflow input
  triggerSchema: z.object({
    size: z.enum(["small", "medium", "large"]),
    toppings: z.array(z.string()),
    specialInstructions: z.string().optional(),
  }),
  steps: [validatePizzaOrder, processPizzaPayment, notifyKitchen],
});
```

## Configuring Step Dependencies

Configure how data flows between steps and when each step should execute:

```ts filename="src/mastra/workflows/index.ts" showLineNumbers copy
// Map trigger data to first step
pizzaWorkflow.config("validatePizzaOrder", {
  variables: {
    size: { stepId: "trigger", path: "size" },
    toppings: { stepId: "trigger", path: "toppings" },
    specialInstructions: { stepId: "trigger", path: "specialInstructions" },
  },
});

// Process payment after validation
pizzaWorkflow.config("processPizzaPayment", {
  dependsOn: ["validatePizzaOrder"],
  variables: {
    price: { stepId: "validatePizzaOrder", path: "price" },
  },
});

// Notify kitchen only after successful payment
pizzaWorkflow
  .config("notifyKitchen", {
    dependsOn: ["validatePizzaOrder", "processPizzaPayment"],
    condition: {
      ref: { stepId: "processPizzaPayment", path: "status" },
      query: { $eq: "success" },
    },
    variables: {
      status: { stepId: "processPizzaPayment", path: "status" },
    },
  })
  .commit();
```

## Executing the Workflow

Execute the workflow with initial data:

```ts filename="src/mastra/workflows/index.ts" showLineNumbers copy
const result = await pizzaWorkflow.execute({
  size: "medium",
  toppings: ["pepperoni", "mushroom"],
  specialInstructions: "no onions",
});

console.log(result);
```

## Key Concepts Demonstrated

1. **Schema Validation**: Each step defines input/output schemas using Zod
2. **Sequential Execution**: Steps run in order using `dependsOn`
3. **Data Flow**: Variables pass data between steps
4. **Conditional Logic**: Kitchen notification only happens after successful payment
5. **Error Handling**: Built-in validation prevents invalid data flow

## Reference Documentation

For more details on specific workflow features, see:

- [Workflow Configuration](../reference/workflows/workflow.mdx)
- [Step Configuration](../reference/workflows/step.mdx)
- [Conditions](../reference/workflows/condition.mdx)
- [Execution](../reference/workflows/execute.mdx)
