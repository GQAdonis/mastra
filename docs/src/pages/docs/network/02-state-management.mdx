---
title: "State Management in Agent Networks | Network Documentation | Mastra"
description: Learn how to use state management in Mastra agent networks to share information between agents and maintain context throughout multi-step workflows.
---

# State Management in Agent Networks

State management is a crucial feature of Agent Networks that allows agents to share information and maintain context throughout a multi-step workflow. The network state persists between agent calls, enabling complex interactions and data sharing without having to pass everything through inputs and outputs.

## 1. Network State Basics

The `NetworkState` class provides a simple key-value store that persists throughout the network execution:

```ts showLineNumbers copy
import { AgentNetwork, NetworkState } from "@mastra/core/network";

// Create a network with initial state
const network = new AgentNetwork({
  name: "Stateful Network",
  agents: [agentA, agentB],
  routingModel: openai("gpt-4o"),
  initialState: new NetworkState({
    counter: 0,
    items: [],
    user: { name: "Alice", preferences: { theme: "dark" } },
  }),
});
```

### Accessing State in the Router

The router function receives the current state as part of the `RouterState` object:

```ts showLineNumbers copy
const router = async ({ callCount, state, lastResult }) => {
  // Read values from state
  const counter = state.get("counter");
  console.log(`Current counter: ${counter}`);
  
  // Update state values
  state.set("counter", counter + 1);
  
  // Routing logic
  if (callCount === 0) return agentA;
  return undefined;
};
```

## 2. Working with State

### Reading and Writing State

The `NetworkState` class provides methods to get and set values:

```ts showLineNumbers copy
// Reading values
const counter = state.get("counter"); // Returns the value or undefined if not set
const user = state.get("user");
const theme = user?.preferences?.theme;

// Writing values
state.set("counter", 42);
state.set("items", ["item1", "item2"]);

// Updating nested objects
const user = state.get("user") || {};
user.preferences = { ...user.preferences, theme: "light" };
state.set("user", user);
```

### Checking if Keys Exist

You can check if a key exists in the state:

```ts showLineNumbers copy
if (state.has("user")) {
  const user = state.get("user");
  // Do something with user
}
```

### Removing Keys

You can remove keys from the state:

```ts showLineNumbers copy
state.delete("temporaryData");
```

### Cloning State

You can create a copy of the state:

```ts showLineNumbers copy
const stateCopy = state.clone();
```

## 3. State Management Patterns

### Accumulating Data

Collect data across multiple agent calls:

```ts showLineNumbers copy
const router = async ({ callCount, state, lastResult }) => {
  // Get the current results array or initialize it
  const results = state.get("results") || [];
  
  // Add the latest result
  results.push({
    step: callCount,
    result: lastResult,
    timestamp: new Date().toISOString(),
  });
  
  // Update the state
  state.set("results", results);
  
  // Routing logic
  if (callCount < 3) {
    return dataCollectionAgent;
  }
  
  return summaryAgent; // Summarize all collected data
};
```

### Tracking Progress

Track the progress of a multi-step workflow:

```ts showLineNumbers copy
const router = async ({ callCount, state }) => {
  // Define the workflow steps
  const workflow = [
    { name: "research", agent: researchAgent, complete: false },
    { name: "analyze", agent: analysisAgent, complete: false },
    { name: "summarize", agent: summaryAgent, complete: false },
  ];
  
  // Initialize workflow state if not already set
  if (!state.has("workflow")) {
    state.set("workflow", workflow);
  }
  
  // Get the current workflow state
  const currentWorkflow = state.get("workflow");
  
  // Find the first incomplete step
  const nextStep = currentWorkflow.find(step => !step.complete);
  
  if (nextStep) {
    // Mark this step as complete for the next call
    nextStep.complete = true;
    state.set("workflow", currentWorkflow);
    
    // Return the agent for this step
    return nextStep.agent;
  }
  
  return undefined; // All steps complete
};
```

### Conditional Processing

Use state to implement conditional processing:

```ts showLineNumbers copy
const router = async ({ callCount, state, lastResult }) => {
  // First call always goes to the classifier
  if (callCount === 0) {
    return classifierAgent;
  }
  
  // After classification, store the category
  if (callCount === 1) {
    state.set("category", lastResult.toLowerCase());
    return processingAgent;
  }
  
  // Process differently based on category
  const category = state.get("category");
  
  if (category.includes("technical")) {
    if (!state.get("technicalProcessed")) {
      state.set("technicalProcessed", true);
      return technicalAgent;
    }
  }
  
  if (category.includes("business")) {
    if (!state.get("businessProcessed")) {
      state.set("businessProcessed", true);
      return businessAgent;
    }
  }
  
  // Final step for all categories
  return summaryAgent;
};
```

## 4. Advanced State Management

### Passing State to Agents

You can include state information in the input to agents:

```ts showLineNumbers copy
const network = new AgentNetwork({
  name: "State-Aware Network",
  agents: [agentA, agentB],
  router: async ({ callCount, state, lastResult, input }) => {
    if (callCount === 0) {
      return agentA;
    }
    
    if (callCount === 1) {
      // Store the first result
      state.set("firstResult", lastResult);
      
      // Create a custom input for the second agent that includes state info
      const customInput = `
        Original query: ${input}
        First agent result: ${lastResult}
        Current state:
        - Items: ${JSON.stringify(state.get("items") || [])}
        - Counter: ${state.get("counter") || 0}
        
        Please process this information.
      `;
      
      // Store the custom input for use in the executeNetworkWithStream method
      state.set("customInput", customInput);
      
      return agentB;
    }
    
    return undefined;
  },
});
```

### State Initialization

Initialize state with default values:

```ts showLineNumbers copy
// Create a helper function to initialize state
function initializeState() {
  return new NetworkState({
    startTime: new Date().toISOString(),
    counter: 0,
    items: [],
    flags: {
      processingComplete: false,
      errorOccurred: false,
    },
    results: [],
  });
}

// Use the helper function when creating the network
const network = new AgentNetwork({
  name: "Initialized Network",
  agents: [agentA, agentB],
  initialState: initializeState(),
  // ...
});
```

### State Persistence

For long-running workflows, you might want to persist state between network runs:

```ts showLineNumbers copy
// Save state to storage
async function saveNetworkState(networkId, state) {
  await db.put(`network:${networkId}:state`, JSON.stringify(state.toJSON()));
}

// Load state from storage
async function loadNetworkState(networkId) {
  const stateJson = await db.get(`network:${networkId}:state`);
  return new NetworkState(JSON.parse(stateJson));
}

// Example usage in an API route
export async function POST(req: Request) {
  const { networkId, input } = await req.json();
  
  // Load previous state if it exists
  let initialState;
  try {
    initialState = await loadNetworkState(networkId);
  } catch (error) {
    // No previous state, create a new one
    initialState = new NetworkState({});
  }
  
  // Create network with loaded state
  const network = new AgentNetwork({
    name: "Persistent Network",
    agents: [agentA, agentB],
    initialState,
    // ...
  });
  
  // Run the network
  const result = await network.generate(input);
  
  // Save the updated state
  await saveNetworkState(networkId, result.state);
  
  return Response.json({ result: result.output });
}
```

## 5. Best Practices

- **Use Descriptive Keys**: Choose clear, descriptive names for state keys
- **Initialize State**: Always initialize state with default values
- **Handle Missing Values**: Check if keys exist before accessing them
- **Immutable Updates**: When updating nested objects, create new objects rather than modifying existing ones
- **Avoid Overly Complex State**: Keep state manageable and focused on what's needed
- **Document State Structure**: Document the expected structure of your state for other developers

## Next Steps

- Explore [Streaming](./03-streaming.mdx) for real-time updates during network execution
- Learn about [Custom Routing](./01-custom-routing.mdx) for advanced routing strategies
- Return to the [Overview](./00-overview.mdx) for general network concepts
